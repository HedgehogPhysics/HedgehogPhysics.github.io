<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chess Progress — Hedgehog Physics</title>
  <meta name="description" content="Blitz rating progress across Lichess and Chess.com." />
  <link rel="stylesheet" href="styles.css" />
  <style>
    .chess-hero {
      position: relative;
      padding: 120px 18px 60px;
      overflow: hidden;
    }
    .chess-hero::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse 50% 60% at 90% 10%, rgba(42,109,245,0.08) 0%, transparent 70%),
        radial-gradient(ellipse 40% 50% at 5% 90%, rgba(124,58,237,0.07) 0%, transparent 70%);
      pointer-events: none;
    }
    .chess-hero-inner {
      max-width: 1060px;
      margin: 0 auto;
      position: relative;
    }
    .chess-hero h1 {
      margin: 16px 0 12px;
      font-size: clamp(36px, 5vw, 62px);
      letter-spacing: -1px;
      line-height: 1.05;
    }
    .chess-hero p {
      margin: 0;
      max-width: 58ch;
      font-size: clamp(15px, 1.8vw, 18px);
      color: var(--muted);
      line-height: 1.65;
    }
    .chess-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 22px;
    }
    .chess-meta .meta-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--card-bg);
      backdrop-filter: blur(8px);
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
    }
    .chess-meta .dot {
      width: 6px; height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .chess-content {
      max-width: 1060px;
      margin: 0 auto;
      padding: 0 18px 80px;
    }

    /* ── Rating summary cards ── */
    .rating-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 14px;
      margin-bottom: 48px;
    }
    .rating-card {
      padding: 20px 22px;
      border-radius: var(--radius);
      border: 1px solid var(--line);
      background: var(--card-bg);
      backdrop-filter: blur(8px);
      position: relative;
      overflow: hidden;
    }
    .rating-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
      border-radius: 3px 3px 0 0;
    }
    .rating-card.lichess::before { background: #2a6df5; }
    .rating-card.chesscom::before { background: #81b64c; }
    .rating-card-platform {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .5px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .rating-card-value {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: -1px;
      line-height: 1;
      margin-bottom: 4px;
    }
    .rating-card.lichess .rating-card-value { color: #2a6df5; }
    .rating-card.chesscom .rating-card-value { color: #81b64c; }
    .rating-card-label { font-size: 12px; color: var(--muted); }
    .rating-card-change { font-size: 13px; font-weight: 700; margin-top: 8px; }
    .rating-card-change.up   { color: #22c55e; }
    .rating-card-change.down { color: #ef4444; }
    .rating-card-change.neutral { color: var(--muted); }

    /* ── Chart sections ── */
    .chart-section {
      border-top: 1px solid var(--line);
      padding-top: 36px;
      margin-top: 36px;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .chart-title {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .chart-title h2 {
      margin: 0;
      font-size: 22px;
      letter-spacing: -.3px;
    }
    .platform-badge {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .3px;
    }
    .badge-lichess  { background: rgba(42,109,245,0.12); color: #2a6df5; }
    .badge-chesscom { background: rgba(129,182,76,0.15); color: #5a9432; }
    @media (prefers-color-scheme: dark) {
      .badge-chesscom { color: #81b64c; }
    }
    .chart-link {
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      text-decoration: none;
      padding: 6px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: var(--card-bg);
      transition: color .15s, border-color .15s;
    }
    .chart-link:hover { color: var(--ink); border-color: rgba(42,109,245,.3); }

    /* ── Timeframe selector ── */
    .chart-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 14px;
    }
    .timeframe-btns {
      display: flex;
      gap: 6px;
    }
    .tf-btn {
      padding: 6px 13px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: transparent;
      color: var(--muted);
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      font-family: inherit;
      transition: all .15s;
    }
    .tf-btn:hover { background: var(--card-bg); color: var(--ink); }
    .tf-btn.active {
      background: var(--ink);
      color: var(--bg);
      border-color: var(--ink);
    }

    /* ── Canvas chart wrapper ── */
    .chart-wrap {
      position: relative;
      width: 100%;
      height: 300px;
      border-radius: var(--radius);
      border: 1px solid var(--line);
      background: var(--card-bg);
      backdrop-filter: blur(8px);
      overflow: hidden;
    }
    .chart-wrap canvas {
      position: absolute;
      inset: 0;
      width: 100% !important;
      height: 100% !important;
    }

    /* ── Tooltip ── */
    .chart-tooltip {
      position: absolute;
      background: var(--ink);
      color: var(--bg);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 700;
      pointer-events: none;
      opacity: 0;
      transition: opacity .1s;
      white-space: nowrap;
      z-index: 10;
      transform: translate(-50%, -110%);
    }

    /* ── Loading / error states ── */
    .chart-loading {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: var(--muted);
      font-size: 14px;
    }
    .spinner {
      width: 28px; height: 28px;
      border: 2px solid var(--line);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin .8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .chart-error {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: var(--muted);
      font-size: 14px;
      text-align: center;
      padding: 20px;
    }

    /* ── Annotations ── */
    .annotations {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .annotation {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--card-bg);
      font-size: 13px;
    }
    .annotation-date {
      font-weight: 700;
      color: var(--muted);
      white-space: nowrap;
      min-width: 70px;
      font-size: 12px;
      padding-top: 1px;
    }
    .annotation-text { color: var(--ink); line-height: 1.5; }
    .annotation-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 4px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-decoration: none;
      color: var(--muted);
      font-size: 14px;
      font-weight: 600;
      transition: color .15s;
    }
    .back-link:hover { color: var(--ink); }
    .back-link svg { transition: transform .15s; }
    .back-link:hover svg { transform: translateX(-3px); }

    @media (prefers-color-scheme: dark) {
      .chess-hero::before {
        background:
          radial-gradient(ellipse 50% 60% at 90% 10%, rgba(42,109,245,0.13) 0%, transparent 70%),
          radial-gradient(ellipse 40% 50% at 5% 90%, rgba(124,58,237,0.10) 0%, transparent 70%);
      }
      .tf-btn.active { background: #eeeef0; color: #0e0f11; border-color: #eeeef0; }
    }
  </style>
</head>
<body>

  <header class="hero" style="min-height:unset; padding-bottom:0;">
    <nav class="nav">
      <a class="brand" href="index.html">Hedgehog Physics</a>
      <div class="nav-links">
        <a href="index.html#about">About</a>
        <a href="index.html#art">Artwork</a>
        <a href="supervision.html">Supervisions</a>
        <a href="chess.html" style="color:var(--ink);">Chess</a>
      </div>
    </nav>
  </header>

  <section class="chess-hero">
    <div class="chess-hero-inner">
      <a class="back-link" href="index.html">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Back to home
      </a>
      <h1>Chess Progress</h1>
      <p>Live blitz rating history pulled from Lichess and Chess.com.</p>
      <div class="chess-meta">
        <span class="meta-tag"><span class="dot" style="background:#2a6df5"></span>Lichess · BigSoonj</span>
        <span class="meta-tag"><span class="dot" style="background:#81b64c"></span>Chess.com · Hog_Hedge</span>
        <span class="meta-tag"><span class="dot" style="background:var(--accent2)"></span>Blitz</span>
      </div>
    </div>
  </section>

  <main class="chess-content">

    <!-- Summary cards -->
    <div class="rating-cards">
      <div class="rating-card lichess">
        <div class="rating-card-platform">Lichess</div>
        <div class="rating-card-value" id="lichess-current">—</div>
        <div class="rating-card-label">Blitz rating</div>
        <div class="rating-card-change neutral" id="lichess-change">Loading…</div>
      </div>
      <div class="rating-card chesscom">
        <div class="rating-card-platform">Chess.com</div>
        <div class="rating-card-value" id="chesscom-current">—</div>
        <div class="rating-card-label">Blitz rating</div>
        <div class="rating-card-change neutral" id="chesscom-change">Loading…</div>
      </div>
    </div>

    <!-- ── Lichess chart ── -->
    <div class="chart-section">
      <div class="chart-header">
        <div class="chart-title">
          <h2>Lichess</h2>
          <span class="platform-badge badge-lichess">Blitz</span>
        </div>
        <a class="chart-link" href="https://lichess.org/@/BigSoonj" target="_blank" rel="noopener">View profile ↗</a>
      </div>
      <div class="chart-controls">
        <div class="timeframe-btns" id="lichess-tf">
          <button class="tf-btn" data-months="1"  onclick="setTimeframe('lichess',1,this)">1M</button>
          <button class="tf-btn" data-months="3"  onclick="setTimeframe('lichess',3,this)">3M</button>
          <button class="tf-btn" data-months="6"  onclick="setTimeframe('lichess',6,this)">6M</button>
          <button class="tf-btn" data-months="12" onclick="setTimeframe('lichess',12,this)">1Y</button>
          <button class="tf-btn active" data-months="0" onclick="setTimeframe('lichess',0,this)">All</button>
        </div>
      </div>
      <div class="chart-wrap" id="lichess-wrap">
        <div class="chart-loading" id="lichess-loading">
          <div class="spinner"></div>
          <span>Fetching from Lichess…</span>
        </div>
        <div class="chart-error" id="lichess-error">
          ⚠️ Could not load Lichess data.<br>Check your connection or try refreshing.
        </div>
        <canvas id="lichess-canvas"></canvas>
        <div class="chart-tooltip" id="lichess-tooltip"></div>
      </div>
      <div class="annotations">
        <div class="annotation">
          <span class="annotation-dot" style="background:#2a6df5"></span>
          <span class="annotation-date">Add date</span>
          <span class="annotation-text">Add a note about a milestone, tournament, or improvement here.</span>
        </div>
      </div>
    </div>

    <!-- ── Chess.com chart ── -->
    <div class="chart-section">
      <div class="chart-header">
        <div class="chart-title">
          <h2>Chess.com</h2>
          <span class="platform-badge badge-chesscom">Blitz</span>
        </div>
        <a class="chart-link" href="https://www.chess.com/member/Hog_Hedge" target="_blank" rel="noopener">View profile ↗</a>
      </div>
      <div class="chart-controls">
        <div class="timeframe-btns" id="chesscom-tf">
          <button class="tf-btn" data-months="1"  onclick="setTimeframe('chesscom',1,this)">1M</button>
          <button class="tf-btn" data-months="3"  onclick="setTimeframe('chesscom',3,this)">3M</button>
          <button class="tf-btn" data-months="6"  onclick="setTimeframe('chesscom',6,this)">6M</button>
          <button class="tf-btn" data-months="12" onclick="setTimeframe('chesscom',12,this)">1Y</button>
          <button class="tf-btn active" data-months="0" onclick="setTimeframe('chesscom',0,this)">All</button>
        </div>
      </div>
      <div class="chart-wrap" id="chesscom-wrap">
        <div class="chart-loading" id="chesscom-loading">
          <div class="spinner"></div>
          <span>Fetching from Chess.com…</span>
        </div>
        <div class="chart-error" id="chesscom-error">
          ⚠️ Chess.com blocks direct API calls from browsers.<br>
          <a href="https://www.chess.com/member/Hog_Hedge" target="_blank" style="color:var(--accent)">View your Chess.com profile directly ↗</a>
        </div>
        <canvas id="chesscom-canvas"></canvas>
        <div class="chart-tooltip" id="chesscom-tooltip"></div>
      </div>
      <div class="annotations">
        <div class="annotation">
          <span class="annotation-dot" style="background:#81b64c"></span>
          <span class="annotation-date">Add date</span>
          <span class="annotation-text">Add a note about a milestone, tournament, or improvement here.</span>
        </div>
      </div>
    </div>

  </main>

  <footer class="footer" style="max-width:1060px;margin:0 auto;padding:0 18px 40px;">
    <span>© <span id="year"></span> Hedgehog Physics</span>
  </footer>

<script>
document.getElementById('year').textContent = new Date().getFullYear();

const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
const COLORS = {
  lichess:  '#2a6df5',
  chesscom: '#81b64c',
  grid:  isDark ? 'rgba(238,238,240,0.07)' : 'rgba(16,17,20,0.07)',
  label: isDark ? 'rgba(238,238,240,0.45)' : 'rgba(16,17,20,0.45)',
  bg:    isDark ? '#0e0f11' : '#ffffff',
};

// Store full datasets so we can re-slice on timeframe change
const DATA = { lichess: null, chesscom: null };
const TIMEFRAME = { lichess: 0, chesscom: 0 }; // 0 = all

// ── Filter data by months ──
function filterByMonths(labels, values, months) {
  if (!months) return { labels, values };
  const cutoff = new Date();
  cutoff.setMonth(cutoff.getMonth() - months);
  const filtered = labels.map((l, i) => ({ l, v: values[i] }))
    .filter(({ l }) => {
      const d = new Date(l);
      return !isNaN(d) && d >= cutoff;
    });
  if (filtered.length < 2) return { labels, values }; // not enough data, show all
  return { labels: filtered.map(x => x.l), values: filtered.map(x => x.v) };
}

// ── Timeframe button handler ──
function setTimeframe(platform, months, btn) {
  TIMEFRAME[platform] = months;
  // Update active button
  btn.closest('.timeframe-btns').querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  // Redraw
  if (DATA[platform]) {
    const { labels, values } = filterByMonths(DATA[platform].labels, DATA[platform].values, months);
    redrawChart(platform + '-canvas', labels, values, COLORS[platform], platform + '-tooltip');
    updateCard(platform, values[values.length - 1], values);
  }
}

// ── Draw / redraw chart ──
function redrawChart(canvasId, labels, values, color, tooltipId) {
  const canvas = document.getElementById(canvasId);
  if (!canvas || values.length < 2) return;
  const tooltipEl = document.getElementById(tooltipId);
  const ctx = canvas.getContext('2d');
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  // Store for resize
  canvas._chartData = { labels, values, color, tooltipId };

  function render(animated) {
    const W = canvas.parentElement.clientWidth;
    const H = canvas.parentElement.clientHeight;
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const PAD = { top: 24, right: 20, bottom: 44, left: 56 };
    const cW = W - PAD.left - PAD.right;
    const cH = H - PAD.top  - PAD.bottom;
    const n  = values.length;

    const minV = Math.min(...values);
    const maxV = Math.max(...values);
    const range = maxV - minV || 1;
    const lo = minV - range * 0.12;
    const hi = maxV + range * 0.12;

    const xOf = i => PAD.left + (i / (n - 1)) * cW;
    const yOf = v => PAD.top  + (1 - (v - lo) / (hi - lo)) * cH;

    // Grid
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for (let s = 0; s <= 5; s++) {
      const v = lo + (hi - lo) * (s / 5);
      const y = yOf(v);
      ctx.beginPath(); ctx.moveTo(PAD.left, y); ctx.lineTo(PAD.left + cW, y); ctx.stroke();
      ctx.fillStyle = COLORS.label;
      ctx.font = '11px ui-sans-serif, system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(Math.round(v), PAD.left - 8, y + 4);
    }

    // X labels — show ~6 evenly spaced, formatted nicely
    const step = Math.max(1, Math.floor(n / 6));
    ctx.fillStyle = COLORS.label;
    ctx.font = '11px ui-sans-serif, system-ui, sans-serif';
    ctx.textAlign = 'center';
    for (let i = 0; i < n; i += step) {
      const raw = labels[i];
      const d = new Date(raw);
      const lbl = isNaN(d) ? raw : d.toLocaleDateString('en-GB', { month: 'short', year: '2-digit' });
      ctx.fillText(lbl, xOf(i), H - PAD.bottom + 18);
    }

    return { xOf, yOf, PAD, cW, cH, W, H };
  }

  // Animate
  const duration = 1200;
  const start = performance.now();

  function frame(now) {
    const t = Math.min((now - start) / duration, 1);
    const ease = 1 - Math.pow(1 - t, 3);
    const { xOf, yOf, PAD, H } = render(true);
    const drawCount = Math.max(2, Math.round(ease * values.length));

    // Fill
    const grad = ctx.createLinearGradient(0, PAD.top, 0, H - PAD.bottom);
    grad.addColorStop(0, color + '40');
    grad.addColorStop(1, color + '00');
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let i = 1; i < drawCount; i++) ctx.lineTo(xOf(i), yOf(values[i]));
    ctx.lineTo(xOf(drawCount - 1), H - PAD.bottom);
    ctx.lineTo(xOf(0), H - PAD.bottom);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();

    // Line
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let i = 1; i < drawCount; i++) ctx.lineTo(xOf(i), yOf(values[i]));
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.2;
    ctx.lineJoin = 'round';
    ctx.stroke();

    // End dot
    const lx = xOf(drawCount - 1), ly = yOf(values[drawCount - 1]);
    ctx.beginPath(); ctx.arc(lx, ly, 5, 0, Math.PI * 2);
    ctx.fillStyle = color; ctx.fill();
    ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI * 2);
    ctx.fillStyle = isDark ? '#0e0f11' : '#fff'; ctx.fill();

    if (t < 1) requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

  // ── Hover tooltip ──
  function getHoverIndex(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const W = canvas.parentElement.clientWidth;
    const PAD = { left: 56, right: 20 };
    const cW = W - PAD.left - PAD.right;
    const n = values.length;
    const idx = Math.round(((mx - PAD.left) / cW) * (n - 1));
    return Math.max(0, Math.min(n - 1, idx));
  }

  canvas.onmousemove = (e) => {
    const { xOf, yOf } = render(false);
    const i = getHoverIndex(e);
    const x = xOf(i), y = yOf(values[i]);

    // Redraw with hover dot
    const { PAD, H } = render(false);
    const grad = ctx.createLinearGradient(0, PAD.top, 0, H - PAD.bottom);
    grad.addColorStop(0, color + '40');
    grad.addColorStop(1, color + '00');
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let j = 1; j < values.length; j++) ctx.lineTo(xOf(j), yOf(values[j]));
    ctx.lineTo(xOf(values.length - 1), H - PAD.bottom);
    ctx.lineTo(xOf(0), H - PAD.bottom);
    ctx.closePath(); ctx.fillStyle = grad; ctx.fill();
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let j = 1; j < values.length; j++) ctx.lineTo(xOf(j), yOf(values[j]));
    ctx.strokeStyle = color; ctx.lineWidth = 2.2; ctx.lineJoin = 'round'; ctx.stroke();

    // Vertical crosshair
    ctx.beginPath();
    ctx.moveTo(x, PAD.top); ctx.lineTo(x, H - PAD.bottom);
    ctx.strokeStyle = color + '55'; ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);

    // Hover dot
    ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = color; ctx.fill();
    ctx.beginPath(); ctx.arc(x, y, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = isDark ? '#0e0f11' : '#fff'; ctx.fill();

    // Tooltip
    const raw = labels[i];
    const d = new Date(raw);
    const dateLbl = isNaN(d) ? raw : d.toLocaleDateString('en-GB', { month: 'short', day: 'numeric', year: 'numeric' });
    if (tooltipEl) {
      tooltipEl.textContent = `${values[i]}  ·  ${dateLbl}`;
      tooltipEl.style.left = x + 'px';
      tooltipEl.style.top  = y + 'px';
      tooltipEl.style.opacity = '1';
    }
  };

  canvas.onmouseleave = () => {
    if (tooltipEl) tooltipEl.style.opacity = '0';
    // Redraw clean
    const { xOf, yOf, PAD, H } = render(false);
    const grad = ctx.createLinearGradient(0, PAD.top, 0, H - PAD.bottom);
    grad.addColorStop(0, color + '40'); grad.addColorStop(1, color + '00');
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let j = 1; j < values.length; j++) ctx.lineTo(xOf(j), yOf(values[j]));
    ctx.lineTo(xOf(values.length - 1), H - PAD.bottom);
    ctx.lineTo(xOf(0), H - PAD.bottom);
    ctx.closePath(); ctx.fillStyle = grad; ctx.fill();
    ctx.beginPath();
    ctx.moveTo(xOf(0), yOf(values[0]));
    for (let j = 1; j < values.length; j++) ctx.lineTo(xOf(j), yOf(values[j]));
    ctx.strokeStyle = color; ctx.lineWidth = 2.2; ctx.lineJoin = 'round'; ctx.stroke();
    const lx = xOf(values.length - 1), ly = yOf(values[values.length - 1]);
    ctx.beginPath(); ctx.arc(lx, ly, 5, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill();
    ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI * 2);
    ctx.fillStyle = isDark ? '#0e0f11' : '#fff'; ctx.fill();
  };
}

// ── Update summary card ──
function updateCard(id, current, values) {
  document.getElementById(id + '-current').textContent = current;
  const changeEl = document.getElementById(id + '-change');
  const diff = current - values[0];
  const sign = diff > 0 ? '+' : '';
  const period = TIMEFRAME[id] ? `last ${TIMEFRAME[id]}mo` : 'all time';
  changeEl.textContent = `${sign}${diff} (${period})`;
  changeEl.className = 'rating-card-change ' + (diff > 0 ? 'up' : diff < 0 ? 'down' : 'neutral');
}

function showError(id) {
  document.getElementById(id + '-loading').style.display = 'none';
  document.getElementById(id + '-error').style.display = 'flex';
}
function hideLoading(id) {
  document.getElementById(id + '-loading').style.display = 'none';
}

// ══════════════════════════════════
//  LICHESS
// ══════════════════════════════════
async function loadLichess() {
  try {
    const res = await fetch('https://lichess.org/api/user/BigSoonj/rating-history');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    const blitz = data.find(d => d.name === 'Blitz');
    if (!blitz || !blitz.points.length) throw new Error('No blitz data');

    const points = blitz.points;
    const labels = points.map(p => new Date(p[0], p[1], p[2]).toISOString().split('T')[0]);
    const values = points.map(p => p[3]);

    DATA.lichess = { labels, values };
    hideLoading('lichess');
    updateCard('lichess', values[values.length - 1], values);
    redrawChart('lichess-canvas', labels, values, COLORS.lichess, 'lichess-tooltip');
  } catch (e) {
    console.error('Lichess:', e);
    showError('lichess');
    document.getElementById('lichess-current').textContent = 'N/A';
    document.getElementById('lichess-change').textContent = 'Could not load';
  }
}

// ══════════════════════════════════
//  CHESS.COM
// ══════════════════════════════════
async function loadChessCom() {
  try {
    const archivesRes = await fetch('https://api.chess.com/pub/player/hog_hedge/games/archives');
    if (!archivesRes.ok) throw new Error('HTTP ' + archivesRes.status);
    const archivesData = await archivesRes.json();
    const archives = archivesData.archives.slice(-12); // last 12 months

    const ratingByMonth = [];
    for (const url of archives) {
      const parts = url.split('/');
      const year = parts[parts.length - 2];
      const month = parts[parts.length - 1];
      try {
        const gamesRes = await fetch(url);
        if (!gamesRes.ok) continue;
        const gamesData = await gamesRes.json();
        const blitzGames = (gamesData.games || []).filter(g => g.time_class === 'blitz');
        if (!blitzGames.length) continue;
        const last = blitzGames[blitzGames.length - 1];
        const rating = last.white?.username?.toLowerCase() === 'hog_hedge'
          ? last.white.rating : last.black.rating;
        ratingByMonth.push({
          label: new Date(year, month - 1, 15).toISOString().split('T')[0],
          rating
        });
      } catch { continue; }
    }

    const statsRes = await fetch('https://api.chess.com/pub/player/hog_hedge/stats');
    if (!statsRes.ok) throw new Error('Stats HTTP ' + statsRes.status);
    const stats = await statsRes.json();
    const currentRating = stats?.chess_blitz?.last?.rating;

    if (!ratingByMonth.length && !currentRating) throw new Error('No data');

    const labels = ratingByMonth.map(r => r.label);
    const values = ratingByMonth.map(r => r.rating);
    if (currentRating && values[values.length - 1] !== currentRating) {
      labels.push(new Date().toISOString().split('T')[0]);
      values.push(currentRating);
    }

    if (values.length < 2) throw new Error('Not enough data points');

    DATA.chesscom = { labels, values };
    hideLoading('chesscom');
    updateCard('chesscom', values[values.length - 1], values);
    redrawChart('chesscom-canvas', labels, values, COLORS.chesscom, 'chesscom-tooltip');
  } catch (e) {
    console.error('Chess.com:', e);
    showError('chesscom');
    document.getElementById('chesscom-current').textContent = 'N/A';
    document.getElementById('chesscom-change').textContent = 'Could not load';
  }
}

// ── Resize handler ──
window.addEventListener('resize', () => {
  ['lichess', 'chesscom'].forEach(p => {
    if (!DATA[p]) return;
    const { labels, values } = filterByMonths(DATA[p].labels, DATA[p].values, TIMEFRAME[p]);
    redrawChart(p + '-canvas', labels, values, COLORS[p], p + '-tooltip');
  });
});

loadLichess();
loadChessCom();
</script>
</body>
</html>
